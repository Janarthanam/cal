use std::collections::{BTreeMap, HashMap};
use std::ops::Bound::Included;
use rand::random;
use rocket::{FromForm, FromFormField};
use rocket::serde::Deserialize;
use rocket::serde::Serialize;

#[derive(Debug, Default, Serialize, Deserialize, Clone,PartialEq,Eq,FromFormField)]
pub enum Status {
    Attending,
    #[default]
    NotAttending,
    Tentative
}

//Slot is a basic calendar slot.
#[derive(Debug, Default, Serialize, Deserialize, Clone, Ord, PartialOrd, PartialEq, Eq, FromForm)]
pub struct Slot {
    pub start_time: u64,
    pub end_time: u64,
    //todo. this can be private
    pub id: Option<u8>,
}

#[derive(Debug,Serialize, Deserialize,Clone, FromForm)]
pub struct Event {
    pub status: Status,
    pub description: Option<String>,
    pub title: Option<String>
}

#[derive(Debug,Serialize, Deserialize,Clone,FromForm)]
pub struct SlotEvent {
    pub slot: Slot,
    pub event: Event
}

#[derive(Debug)]
pub struct Calendar {
    slots: BTreeMap<Slot,Event>
}


///this would implement multiple calendars!?
pub struct Calendars {
    calendars: HashMap<String, Calendar>
}

impl Calendars {
    pub fn new() -> Self {
        Calendars {
            calendars: HashMap::new()
        }
    }

    pub fn get_instance(&self, key: &str) -> Option<& Calendar>
    {
        self.calendars.get(key)
    }

    pub fn create_if_absent(&mut self, key: &str) -> &mut Calendar
    {
        self.calendars.entry(key.to_owned()).or_insert(Calendar::new())
    }

}

impl Calendar {

    //initiate slots
    pub const fn new() -> Self {
        Calendar {
            slots : BTreeMap::new()
        }
    }

    //return the slots for this event.
    //when id is present only specific event is returned.
    pub fn get_events(&self, start_slot: &Slot, end_slot: &Slot) -> Vec<(&Slot,&Event)>
    {
        let events = self.slots.range((Included(start_slot), Included(end_slot)));
        events.collect()
    }

    //get event with a particular sort key
    pub fn get(&self, slot_key: &Slot) -> Option<&Event> {
        self.slots.get(slot_key)
    }

    //If a slot exists, update the slot.
    // A slot is same if start_time, end_time and id is same.
    //If you want to create a new slot, then an id is autogenerated
    // and an insert happens.Currently the one way to indicate insert/update
    // is the presence of id in the slot. This also means, you can't do an update
    // without completing a read in some form, as of now.
    pub fn upsert(&mut self, slot: Slot, event: Event) -> Option<Slot> {
        let upsert_slot = Slot {
            id: Some(slot.id.unwrap_or(random())),
            ..slot
        };

        self.slots.insert(upsert_slot.clone(),event);
        Some(upsert_slot)
    }

    pub fn delete(&mut self, slot: &Slot) -> Option<Event> {
        self.slots.remove(slot)
    }
}

